# day12

## OOP 面向对象

- 类
- 示例化
- 方法
- 对象

### 构造器方法

```python
class BearToy():
    def __init__(self, size, color):
        self.size = size
        self.color = color
```

### __new__

#### __new__ 方法是什么

在2.2以后的版本中, 随着类型(type)和类(class)的统一和新式类的引入, 可以对**标准类型**进行子类化.
下面介绍2个子类化Python类型的例子, 一个是可变类型, 另一个是不可变类型.

__new__方法接受的参数虽然也是和__init__一样，但__init__是在**类实例创建之后调用**，而 __new__方法正是**创建这个类实例**的方法。
__init__ 和 __new__ 最主要的区别在于：

1. __init__ 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。
2. __new__ 通常用于控制生成一个新实例的过程。它是类级别的方法。

> 具体见*person.py*

#### __new__ 作用

依照Python官方文档的说法，__new__方法主要是当你继承一些**不可变**的class时(比如int, str, tuple)， 提供给你一个**自定义这些类的实例化过程**的途径。还有就是实现**自定义的metaclass**。

如, 我们想要一个永远都是正数的整数类型, 通过继承int, 代码如下:

> 具体见 *pos_int.py*

处理浮点型的子类. 每次得到一个货币值(浮点型), 需要通过四舍五入, 变为带2位小数的数值.

> 具体见 *round_float.py*

#### 用`__new__`实现单例

实现 设计模式中的 单例模式(singleton) 。
因为类每一次实例化后产生的过程都是通过__new__来控制的，所以通过重载__new__方法，我们 可以很简单的实现单例模式。

> 见*singleton.py*

## 多重继承

mixin

## 类 内建函数

### issubclass()

### isinstance()

第二个参数可以是类, 可以是类型对象(int等)

### hasattr() getattr() setattr() delattr()

`*attr()`系列函数可以在各种对象下工作, 不限于类和实例.

- hasattr(): 一个对象是否有一个特定的属性, 一般用于访问某属性之前先做一下检查
- getattr() setattr(): 取得和赋值给对象的属性.
    - getattr(): 试图读取一个不存在的属性时, 引发 AttributeError 异常
    - setattr(): 要么加入一个新的属性, 要么取代一个已存在的属性.
- delattr(): 从一个对象中删除属性

### dir()

- 作用在**实例**上时, 显示**实例变量**, 还有在实例所在的类及所有它的基类中定义的**方法和类属性**
- 作用在**类**上时, 显示类以及它的所有基类的`__dict__`中的内容. 但不会显示定义在元类(metaclass)中的类属性.
- 作用在**模块**上时, 显示模块的`__dict__`的内容
- 不带参数时, 显示调用者的局部变量.

### super()

帮助程序员找出对应的父类, 然后方便调用相关的属性.

### vars()

与dir()类似, 只是给定的 对象参数必须有一个`__dict__`属性.
vars()返回一个字典, 包含了对象存储于其`__dict__`中的属性(key)和值.
如果没有这样的属性, 会引发TypeError异常. 
如果没有提供对象作为vars()的一个参数, 它将显示一个包含本地名字空间的属性(key)及其值的字典, 也就是: locals()

## 用特殊方法定制类


