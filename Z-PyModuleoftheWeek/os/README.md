# OS - 便捷访问操作系统的特定功能

> **目的**：便携式访问操作系统的特定功能。

`os` module提供了对平台相关模块的封装, 如`posix`, `nt`, 和`mac`. 对于所有的平台的可用函数API应该都是一样的, 因此使用`os`模块来提供便捷的功能. 然而, 并非所有功能都在每个平台上可用. 比如很多进程管理功能在windows上就不能用.
这个模块包含创建和管理运行进程或文件系统内容(文件和目录)的大部分内容.


## 检查文件系统内容

- `os.listdir()`: a list of the contents of a directory on the file system. 返回值是给定目录中所有已命名成员的列表。文件，子目录或符号链接之间没有区别。
- `os.walk()`: 递归地遍历一个目录，并为每个子目录生成一个包含*目录路径*的**元组**，该路径的所有直接*子目录*以及该目录中所有*文件*的名称**列表**。
- `os.scandir()`: 如果需要比文件名更多的信息，则使用`scandir()`比`listdir()`更有效，因为在扫描目录时会在一次系统调用中收集更多信息。scandir（）返回目录中items的一系列*DirEntry*实例。该对象具有用于访问关于该文件的元数据的**多个属性和方法**。

> `sys.argv[1]`: 命令行的第二个argv(实际上就是第一个参数)
## 管理文件系统权限

有关文件的详细信息可以使用`stat（）`或`lstat（）`（用于检查可能是符号链接的某些东西的状态）来访问。

### `os.stat()`

> 具体见`os_stat.py`

输出将取决于示例代码的安装方式。尝试在命令行上将不同的文件名传递给os_stat.py。

### `os.chmod()`

在类Unix系统上，可以使用chmod（）更改文件权限，将模式作为**整数**传递。模式值可以使用stat模块中定义的常量来构造。这个例子切换用户的执行权限位：

> 具体见`os_stat_chmod.py`

### `os.access()`

函数access（）可用于测试进程对文件的访问权限。
access（）的库文档包含两个特殊的警告。
首先，在调用access（）方法来测试文件是否可以在实际调用open（）之前打开是没有多大意义的。在这两个调用之间有一个很小的但是真实的时间窗口，在这两个调用之间文件的权限可能会改变。
另一个警告主要适用于扩展posix权限语义的网络文件系统。某些文件系统类型可能会响应进程有权访问文件的posix调用，然后在尝试使用open（）出于某种原因未通过posix调用进行测试时报告失败。
总而言之，最好是使用所需的模式调用`open()`，并在发生问题时捕获引发的`IOError`错误。

> 具体见`os_access.py`

## 创建和删除

在文件系统上有几个用于处理目录的功能，包括创建，列出内容和删除它们。
有两套用于创建和删除目录的功能。
当用mkdir（）创建一个新的目录时，所有的父目录都必须已经存在。当用rmdir（）去除一个目录时，只有子目录（路径的最后一部分）被删除。
相反，`makedirs()`和`removedirs()`则在路径中的所有节点上运行。makedirs（）将创建不存在的路径的任何部分，removedirs（）将删除所有父目录，只要它们是空的。

> 具体见`os_directories.py`

## 使用符号链接

对于支持符号链接的平台和文件系统，有一些使用符号链接的函数。(Windows不支持)

> 具体见`os_symlinks.py`

使用symlinks（）创建一个符号链接, readlink（）来读取它以确定链接指向的原始文件。lstat（）函数类似于stat（），但在符号链接上运行。

## 安全地替换现有的文件

替换或重命名现有的文件不是幂等的，并可能使应用程序出现竞争情况。rename（）和replace（）函数实现这些操作的安全算法，尽可能在posix兼容系统上使用原子操作。

> 具体见`os_rename_replace.py`

rename（）和replace（）函数在大多数时间跨文件系统工作。重命名文件可能会失败，如果它被移动到一个新的文件系统或者如果目的地已经存在。

## 检测和更改进程所有者

os提供的下一组函数用于确定和更改进程所有者ID。这些是守护程序或特殊系统程序的作者最常使用的，它们需要更改权限级别而不是以root身份运行。本节不尝试解释unix安全性，流程所有者等所有复杂的细节。请参阅本节末尾的参考列表以获取更多详细信息。

以下示例显示一个进程的实际有效用户和组信息，然后更改有效值。这与守护进程在系统引导过程中以root身份启动时需要执行的操作类似，以降低特权级别并以不同的用户身份运行。

> **注意**:
> 在运行该示例之前，请更改`test_gid`和`test_uid`值以匹配在系统上定义的真实用户。
